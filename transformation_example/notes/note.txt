c++ 행렬/ 벡터 연산

	glsl의 경우 내부적으로 행렬 및 벡터와 관련된 다양한 기능 및 내부 함수 제공

	c++에는 기본적인 수학적 연산 외에 선형대수 관련 기능은 제공하지 않음 ->라이브러리 이용


	*C++ 선형대수 라이브러리

		eigen3: 가장 많이 사용되는 c++ 선형대수 라이브러리
			
			일반적인 n차원 선형대수 연산

		GLM: OpenGL Math 라이브러리

			3d 그래픽스에 필요한 4차원 선형대수 연산


Coordinate System

	*좌표계
		어떤 정점의 위치를 기술하기 위한 기준
		선형 변환은 한 좌표계로 기술된 벡터를 다른 좌표계에 대해 기술하는 변환으로 해석할 수 있음


	*space

		world space
		Local(object) space
		View(Eye) space
		Screen space




	*좌표 공간 간 변환

		OpenGL의 그림이 그려지는 공간: 
			1) [-1,1]범위로 normalized 된 공간
			2) Canonical space


		object들은 local space 기준으로 기술


		model -view transform (local space -> world space -> view space) 
		-> canonical space


	*Transform Matrix

		model: local -> world
		view: world -> camera
		projection: camera -> canonical
		clip space에서 [-1.1] 범위 밖으로 벗어난 면들은 clipping


Orthogonal projection


	*직교 투영

		:원근감 없이 평행한 선이 계속 평행하도록 투영하는 방식 ex) 설계 도면

		1)6개 파라미터: left, right, bottom, top, near, far

		2)z축에 -1: clip space 이후에는 오른손 좌표계에서 왼손 좌표계로 변경

		3)오른손 좌표계 / 왼손 좌표계

			*x축, y축을 화면의 오른/위 방향으로 했을때
			*오른손 좌표계: z축이 화면에서부터 나오는 방향
			*왼손 좌표계: z축이 화면으로 들어가는 방향


Perspective projection

	*원근 투영

		:변환 이전에 평행한 선이 변환 후에 한점에서 만남(소실점), 멀리 있을수록 물체가 작아져 원근감 발생
		

		*4개의 파라미터
			:종횡비(aspect ratio)
			 화각(field of view,FoV)
			 near, far


Transformation

	Local space를 기준으로 한 좌표 v의 clip space 좌표는?

	합쳐서 MVP(model-view-projection) matrix라고도 함

	V_clip = M_projection * M_view * M_model * V_local



Depth Buffer

	1)z buffer

	2)각 픽셀의 컬러값을 저장하는 버퍼 외에, 해당 픽셀의 깊이값(z축값)을 저장

	3)깊이 테스트(depth test)

		*어떤 픽셀값을 업데이트 하기전, 현재 그리려는 픽셀 z값과 깊이 버퍼에 저장된 해당 위치의 z값 비교

		->비교 결과 현재 그리려는 픽셀이 이전에 그려진 픽셀보다 뒤에 있을경우 픽셀을 그리지 않는다.


Depth test in OpenGL


	openGL의 depth buffer 초기값은 1

	1이 가장 뒤에 있고, 0 이 가장 앞을 의미(왼손 좌표계)

	glEnable(GL_DEPTH_TEST)

	glDisable(GL_DEPTH_TEST) 로 깊이 테스트 키고 끌 수 있음

	glDepthFunc() 이용하여 깊이테스트 통과 조건 변경 가능

	깊이 테스트 통과 조건 기본값: GL_LESS


