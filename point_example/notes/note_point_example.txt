1. Shader class design

Shader 클래스 설계
	1) OpenGL shader object를 가지고 있다.
	인스턴스가 생성될 때 로딩할 파일명을 입력받자
	입력된 파일명으로부터 인스턴스 생성이 실패하면 메모리 할당 해제
	c++ 11 smart pointer 활용


	2) 생성자 private인 이유: CreateFromFile() 함수외에 shader 인스턴스 생성 막기 위해서
	get()은 있는데 set()은 없는 이유: shader 오브젝트의 생성 관리는 shader 내부에서만 관리
	loadfile()이 bool을 리턴하는 이유: 생성에 실패할 경우 false를 리턴하기 위해서





2. Smart pointer

	1) c++11 좀더 안전한 포인터

	메모리 할당을 받을 때 소유권에 대한 정보가 있다.
	명시적인 delete 구문이 필요없다.
	std::unique_ptr<>: 해당 메모리 블록을 단독으로 소유
	std::shared_ptr<>: 해당 메모리 블록의 소유권을 공유
	std::weak_ptr<>: 해당 메모리 소유권은 없지만 접근은 가능

	
	*어떻게 더 안전한가? 
		1)unique_ptr<>을 사용하는 경우: 소유권을 가진 인스턴스가
		스코프 밖으로 벗어났을때 메모리 자동 해제

		ex) std::unique_ptr<int> a =std::make_unique();
		    int *b=a.get();

		2)unique_ptr를 사용하는 경우: 소유권을 가진 인스턴스가 일반적인 방법으로 다른 쪽에
		소유권을 이전하려는 경우 에러 발생
		
		ex) std::unique_ptr<int> a= std::make_unique();
		    std::unique_ptr<int> b=a; //에러 발생


		3)std::move() 함수를 사용해서 명시적으로 소유권 이전 가능. 대신 이전에 소유권을 가진
		  인스턴스는 nullptr를 갖게됨


		{
		 std::unique_ptr<int> a= std::make_unique();
		 std::unique_ptr<int> b= std:move(a);
		}
		
	

* glfwInit(); -> glfwWindowHint -> glfwCreateWindow 순서 꼭 지켜야 하는 이유

1) glfwWindowHint는 다음번에 생성될 창의 속성을 "전역변수처럼" 기록해 두는 함수
   
   실제 OpenGL 컨텍스트를 만드는건 glfwCreateWindow 때  이 기록된 힌트를 읽어와서 " 이 조건대로 context 만들어줘"
   하고 os에 요청하는 방식

   즉, 창 생성전까지는 힌트만 저장되고 아무 일도 일어나지 않음


2) 만약 glfwCreateWindow를 먼저 해버린다면?

  창이 이미 기본설정(디폴트=OpenGL 2.1)으로 만들어짐 

-> 그 후에 glfwWindowHint 호출해봤자 이미 생성된 창에는 적용 안됨.

-> 결과: 항상 OpenGL 2.1 컨텍스트만 뜨는 것처럼 보임.


3) 왜 초기화 직후에 해야하나?

	glfwInit()이 GLFW 라이브러리를 초기화하면서 내부상태를 세팅함
	그 직후에 힌트를 지정해야 glfwCreateWindow에서 이 정보를 사용 가능
	만약 초기화 전에 glfwWindowHint를 호출하면, 아직 내부 준비 안된 상태라 의미없거나 무시됨.



*OpenGL remarks

glCreateShader(): OpenGL shader object 생성
glShaderSource(): shader에 소스코드 설정
glCompileShader(): shader 컴파일

glGetShaderiv(): shader에 대한 정수형 정보를 얻어옴
glGetShaderInfoLog(): shader에 대한 로그를 얻어옴. 컴파일 에러 얻어내는 용도로 사용
glDeleteShader(): shader object 제거


